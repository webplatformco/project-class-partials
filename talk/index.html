<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Control Over Image Animation</title>
	<link rel="shortcut icon" href="https://webplatform.design/assets/logo.svg">
	<script src="talk.js" type="module"></script>
	<link rel="stylesheet" href="talk.css">
</head>
<body data-markdown-elements=".md, details.notes, .md-children > :not(.no-md)" class="language-javascript">

<header class="slide" id="cover">
	<h1>
		Class composition
	</h1>
	<h2>Past, present, and future</h2>
	<footer>
		Lea Verou (OpenJS)
	</footer>
</header>

<article class="slide md">
	## ‚ö†Ô∏è Work In Progress ‚ö†Ô∏è

	These slides are a work in progress.
	They will change, likely dramatically.
</article>

<article class="slide md">
	## Needs

	- Modularity
	- Better data modeling (_is a_ vs. _has a_)
	- Coupling: Tightly vs. loosely coupled
	- Type: Identity vs. trait/behavior

	<details class="notes">
		The use cases for multiple inheritance are well-established in the literature.
		On a high level, there are two distinct high-level needs:
		- Modularity for class definitions. Procedural APIs can be broken down into multiple modules, but the story is not quite as smooth for class surface.
		- Better data modeling: Support modeling _has a_ or _does a_ relationships distinctly from _is a_ relationships.
	</details>
</article>

<!-- <article class="slide md">
	## Variables

	- What: State vs logic composition (+ üí† Diamond problem)
	- üïí When: Class definition time vs. post-hoc vs. instance creation time
	- ‚úÖ Contract: Requirements from host class
</article> -->

<section>
	<header class="slide">
		<h2>Composition across languages</h2>
	</header>

	<article class="slide columns-3">
		<h3>Full-on Multiple inheritance</h3>
		<section>
			<h4>Python</h4>
			<pre class="language-python"><code>
				class M1:
					def foo(self): print("M1")

				# M2, M3 elided

				class A(M1, M2, M3):
					pass
			</code></pre>
		</section>
		<section>
			<h4>C++</h4>
			<pre class="language-cpp"><code>
				class M1 {
				public:
					void foo() { std::cout << "M1"; }
				};

				// M2, M3 elided

				class A : public M1,
				          public M2,
				          public M3 {
					// ...
				};
			</code></pre>
		</section>
		<section>
			<h4>Eiffel</h4>
			<pre class="language-eiffel"><code>
				class M1
					feature foo do print("M1") end
				end

				-- M2, M3 elided

				class A inherit M1 M2 M3
					-- ...
				end
			</code></pre>
		</section>
	</article>

	<article class="slide columns-3">
		<h3>Interfaces</h3>
		<section>
			<h4>Java 8+</h4>
			<pre class="language-java"><code>
				interface M1 {
					default void foo() {
						System.out.println("M1");
					}
				}

				// M2, M3 elided

				class A extends B implements M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>C#</h4>
			<pre class="language-csharp"><code>
				interface M1 {
					void foo() { Console.WriteLine("M1"); }
				}

				// M2, M3 elided


				class A extends B implements M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Kotlin</h4>
			<pre class="language-kotlin"><code>
				interface M1 {
					fun foo() { println("M1"); }
				}

				// M2, M3 elided

				class A : B(), M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
	</article>

	<article class="slide columns-3">
		<h3>Mixins</h3>

		<section>
			<h4>Ruby</h4>
			<pre class="language-ruby"><code>
				module M1
					def foo
						puts "M1"
					end
				end

				# M2, M3 elided

				class A < B
					include M1
					include M2
					include M3
				end
			</code></pre>
		</section>
		<section>
			<h4>Dart</h4>
			<pre class="language-dart"><code>
				mixin M1 {
					void foo() { print("M1"); }
				}

				// M2, M3 elided

				class A extends B with M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Groovy</h4>
			<pre class="language-groovy"><code>
				class M1 {
					def foo() { println "M1" }
				}

				// M2, M3 elided

				class A extends B {}

				A.metaClass.mixin M1, M2, M3
			</code></pre>
		</section>
	</article>

	<article class="slide columns-3">
		<h3>Traits</h3>
		<section>
			<h4>PHP</h4>
			<pre class="language-php"><code>
				trait M1 {
					public function foo() {
						echo "M1";
					}
				}

				// M2, M3 elided

				class A extends B {
					use M1, M2, M3;
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Scala</h4>
			<pre class="language-swift"><code>
				trait M1 {
					def foo: String = "M1"
				}

				// M2, M3 elided

				class A extends B with M1 with M2 with M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Rust</h4>
			<pre class="language-rust"><code>
				pub trait M1 {
					fn foo(&self) { println!("M1"); }
				}

				// M2, M3 elided

				// no way to do extends B,
				// only composition or delegation
				struct A;

				impl M1 for A {}
				impl M2 for A {}
				impl M3 for A {}
			</code></pre>
		</section>
	</article>
</section>

<section>
	<header class="slide">
		<h2>Userland patterns</h2>
	</header>

	<article class="slide columns-2">
		<h3>Example going forwards</h3>

		<img src="images/shape.svg" alt="Shape">

		<ul class="md-children">
			<li>Host class: `EquilateralTriangle`
			<li>Superclass: `Triangle`
			<li>Mixin: `RegularPolygon` with a `getArea()` method that implements the formula:
			<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
				<mrow>
					<mi>A</mi><mo>=</mo>
					<mfrac>
						<mrow>
							<mi>n</mi>
							<msup>
								<mi>s</mi><mn>2</mn>
							</msup>
						</mrow>
						<mrow>
							<mn>4</mn><mo>&InvisibleTimes;</mo><mi>tan</mi>
							<mfenced>
								<mfrac><mi>&pi;</mi><mi>n</mi></mfrac>
							</mfenced>
						</mrow>
					</mfrac>
				</mrow>
			</math>
		</div>
	</article>

	<article class="slide">
		<h3>Subclass factories</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				const RegularPolygon = S => class RegularPolygon extends S {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
						       (4 * Math.tan(Math.PI / sides));
					}
				}

				class EquilateralTriangle extends RegularPolygon(Triangle) {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>

			<ul>
				<li class="pro"><code>super</code> works</li>
				<li class="yes">Private members</li>
				<li class="con">Affects inheritance chain</li>
				<li class="no">No <code>instanceof</code> checks</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<h3>Delegation pattern</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				class RegularPolygon {
					constructor (sideLength, sides) {
						this.sideLength = sideLength;
						this.sides = sides;
					}

					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
						       (4 * Math.tan(Math.PI / sides));
					}
				}

				class EquilateralTriangle extends Triangle {
					#regularPolygon = new RegularPolygon(this.sideLength, 3);
					constructor() {
						this.sideLength = sideLength;
					}

					// Glue code
					getArea () {
						return this.#regularPolygon.getArea();
					}
				}
			</code></pre>

			<ul>
				<li class="pro">Separate state</li>
				<li class="pro">Separate inheritance chain</li>
				<li class="yes">Private members</li>
				<li class="no">Glue code tedious and not future proof</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<h3>Prototype mutations</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				const RegularPolygon = {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					}
				};

				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}

				Object.assign(EquilateralTriangle.prototype, RegularPolygon);

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>

			<ul>
				<li class="pro">Flexible</li>
				<li class="pro">Transparent</li>
				<li class="no">No private members</li>
				<li class="no">No <code>instanceof</code> checks</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<h3>Instance mutations</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				const RegularPolygon = {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					}
				};

				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
						Object.assign(this, RegularPolygon);
					}
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>

			<ul>
				<li class="pro">Flexible</li>
				<li class="pro">Transparent</li>
				<li class="con">Inefficient</li>
				<li class="no">No introspection</li>
			</ul>
		</div>
	</article>
</section>

<section>
	<header class="slide">
		<h2>TC39 Stage 1+ proposals</h2>
	</header>

	<article class="slide">
		<header>
			<h3>First-class protocols</h3>
			<a href="https://github.com/tc39/proposal-first-class-protocols" class="subtitle">tc39/proposal-first-class-protocols</a>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				protocol RegularPolygon {
					sideLength;
					sides;

					getArea () {
						let sides = this[RegularPolygon.sides];
						let sideLength = this[RegularPolygon.sideLength];
						return sides * sideLength ** 2 /
						       (4 * Math.tan(Math.PI / sides));
					}
				}

				class EquilateralTriangle extends Triangle {
					[RegularPolygon.sides] = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this[RegularPolygon.sideLength] = sideLength;
					}

					getArea () {
						return this[RegularPolygon.getArea]();
					}
				}
				Protocol.implement(EquilateralTriangle, RegularPolygon);

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
			<ul>
				<li class="pro">Avoids conflicts via symbols</li>
				<li class="pro">Can be applied post-hoc</li>
				<li class="con">Duplicated author intent ‚Üí error conditions</li>
				<li class="con">Manual glue code</li>
				<li class="con">Often criticized for ergonomics</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<header>
			<h3>Maximally minimal mixins</h3>
			<a class="subtitle" href="https://github.com/tc39/proposal-mixins">tc39/proposal-mixins</a>
		</header>


		<div class="sbs">
			<pre class="language-javascript"><code>
				mixin RegularPolygon {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
						       (4 * Math.tan(Math.PI / sides));
					}
				}

				class EquilateralTriangle extends Triangle with RegularPolygon {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
			<ul>
				<li class="pro">Can add API surface AND provides control over conflicts</li>
				<li class="pro"><code>super</code> works</li>
				<li class="pro">Private members</li>
				<li class="pro">Easy to implement</li>
				<li class="con">Inheritance chain pollution</li>
				<li class="con">Class definition time only</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<header>
			<h3>Decorators</h3>
			<a class="subtitle" href="https://github.com/tc39/proposal-decorators">tc39/proposal-decorators</a>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				@RegularPolygon
				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}
			</code></pre>
			<span class="emoji delayed">üòç</span>
		</div>
	</article>
	<article class="slide">
		<header>
			<h3>Peeking behind the curtain</h3>
			<p class="subtitle delayed" data-index="2">Same patterns, just better encapsulated</p>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				function RegularPolygon (Class, context) {
					return class extends Class {
						getArea () {
							if (super.getArea) {
								return super.getArea();
							}

							const {sideLength, sides} = this;
							return sides * sideLength ** 2 /
								   (4 * Math.tan(Math.PI / sides));
						}
					}
				}
			</code></pre>
			<pre class="language-javascript delayed" data-index="1"><code>
				function RegularPolygon (Class, context) {
					Class.prototype.getArea = function() {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					};
				}
			</code></pre>
		</div>

	</article>


</section>

<article class="slide md">
	## Priority of constituencies

	- Consumers > producers
	- Host class author > Mixin author > Platform implementers

	<details class="notes">
		- Web platform's [priority of constituencies](https://www.w3.org/TR/design-principles/#priority-of-constituencies)
		- [Consumers > producers](https://lea.verou.me/blog/2025/user-effort/#consumers-over-producers)
	</details>
</article>

<article class="slide md">
	## Requirements

	- Extend API surface of host class
	- Memory efficient (prototypes > instances)
	- Static introspection (`A` uses `M1`?)
	- Encapsulation
</article>

<article class="slide md">
	## Nice to haves

	- Single declaration of intent
	- Instance introspection (`instanceof`)
</article>

<article class="slide md">
	## Hairiest issues ü™Æ

	- Is post-hoc composition desirable?
	- Should private members be shared?
	- Naming conflicts: explicit vs. implicit
	- Function composition: explicit vs. implicit
</article>

<section>
	<header class="slide">
		<h1>Design space</h1>
	</header>


</section>

<section>
	<header class="slide">
		<h1>How can we make progress?</h1>
	</header>

	<article class="slide md">
		## Different use cases, different primitives?

		- Tightly coupled use cases don't need sophisticated conflict management
		- Tightly coupled use cases don't need post-hoc application
		- Most controversy is around loosely coupled use cases
	</article>

	<article class="slide md">
		## Proposed path forwards

		- High-level primitives for tightly coupled use cases: Class spread syntax
		- Low-level primitives for decoupled use cases: Make userland helpers easier
	</article>
</section>

<section>
	<header class="slide">
		<h2>Class spread syntax</h2>
	</header>

	<article class="slide columns-2">
		<h3>Core idea</h3>

		<div>
			<pre class="yes"><code>const arr = [...arr1, ...arr2];</code></pre>

			<pre class="yes"><code>console.log(...iterable);</code></pre>

			<pre class="yes"><code>const obj = { ...obj1, ...obj2 };</code></pre>

			<pre class="no"><code>
				class A extends B { ...Mixin }
			</code></pre>
		</div>

		<ul>
			<li>Like object spread, but copies descriptors</li>
			<li>Low-level semantics, no sophisticated MRO</li>
		</ul>
	</article>

	<article class="slide">
		<header>
			<h3>Core idea</h3>
			<p class="subtitle">Spreading constructor ‚Üí class definition</p>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				class RegularPolygon {
					constructor (sideLength, sides) {
						this.sideLength = sideLength;
						this.sides = sides;
					}

					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					}
				}
			</code></pre>
			<pre class="language-javascript"><code>
				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}

					...RegularPolygon;
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
		</div>
	</article>

	<article class="slide">
		<header>
			<h3>Core idea</h3>
			<p class="subtitle">Spreading object ‚Üí class definition</p>
		</header>

		<div class="sbs">
			<pre><div class="filename">regular-polygon.js</div><code>
				export function getArea (params = this) {
					const {sideLength, sides} = params;
					return sides * sideLength ** 2 /
							(4 * Math.tan(Math.PI / sides));
				}
			</code></pre>

			<pre class="language-javascript"><code>
				import * as RegularPolygon from "./regular-polygon.js";

				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}

					...{prototype: RegularPolygon};
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
		</div>
	</article>

	<article class="slide md">
		### Use cases

		- Class modularity
		- Code sharing across procedural and OOP APIs
		- Dynamically generating class API surface
		- Rudimentary mixins
	</article>

	<article class="slide">
		<h3><div class="block badge">Use cases</div> Class modularity</h3>

		<div class="sbs center">
			<pre class="language-javascript"><code>
				import tokenize from "./methods/tokenize.js";
				import highlight from "./methods/highlight.js";
				// ...

				class Prism {
					// constructor elided
					tokenize (text, grammar) {
						return tokenize.call(this, text, grammar);
					}
					highlight (text, language, options = {}) {
						return highlight.call(this, text, language, options);
					}
					// ...
				}
			</code></pre>
			<div class="arrow-right"></div>
			<pre class="language-javascript"><code>
				import * as methods from "./methods.js";

				class Prism {
					...methods;
				}
			</code></pre>
		</div>
		<details class="notes">
			- Large classes benefit from modularization for the same reason as procedural APIs.
			Every method requires boilerplate to forward it to the method in the module.
			Function signatures have to be duplicated for typing.
			- This is a similified but real example from [Prism's v2 codebase](https://github.com/PrismJS/prism/blob/v2/src/core/classes/prism.js).
			- [This Babel class](https://github.com/babel/babel/blob/main/packages/babel-traverse/src/path/index.ts) is even more egregious
		</details>
	</article>

	<article class="slide" data-type="Use cases">
		<h3><div class="block badge">Use cases</div> Procedural & OOP Polymorphism</h3>

		<div class="sbs start">
			<div>
				<pre><div class="filename">mix.js</div><code>
					export default function mix (color, color2) {
						// elided
					}
				</code></pre>
				<pre><div class="filename">toString.js</div><code>
					export default function toString (color) {
						// elided
					}
				</code></pre>
				<pre><div class="filename">color.js</div><code>
					import mix from "./mix.js";
					import toString from "./toString.js";

					class Color {
						mix (color) {
							return mix(this, color);
						}
						toString () {
							return toString(this);
						}
					}
				</code>
			</div>
			<div class="arrow-right"></div>
			<div>
				<pre><div class="filename">mix.js</div><code>
					export default function mix (color, color2) {
						if (this) [color, color2] = [this, color];
						// elided
					}
				</code></pre>
				<pre><div class="filename">toString.js</div><code>
					export default function toString (color) {
						let color = this ?? color;
						// elided
					}
				</code></pre>
				<pre><div class="filename">color.js</div><code>
					import mix from "./mix.js";
					import toString from "./toString.js";

					class Color {
						...{prototype: {mix, toString}};
					}
				</code>
			</div>

		</div>
	</article>

	<article class="slide">
		<header>
			<h3><div class="block badge">Use cases</div> Dynamic class API surface</h3>
			<p class="subtitle">For maintainability and future-proofing</p>
		</header>



		<div class="sbs start">
			<pre><code>
				lass EquilateralTriangle extends Triangle {
					#regularPolygon = new RegularPolygon(this.sideLength, 3);

					constructor() {
						this.sideLength = sideLength;
					}

					getArea () {
						return this.#regularPolygon.getArea();
					}

					// ...
				}
			</code></pre>
			<div class="arrow-right"></div>
			<pre><code>
				class EquilateralTriangle extends Triangle {
					#regularPolygon = new RegularPolygon(this.sideLength, 3);

					constructor() {
						this.sideLength = sideLength;
					}

					[...getMembers(RegularPolygon.prototype).map(key =>
						[key, function (...args) {
							return this.#regularPolygon[key](...args);
						}]
					)]
				}
			</code></pre>
		</div>

		<p><span class="badge">Examples</span> Delegation pattern, <code>ElementInternals</code>, First Class Protocols glue code, etc.</p>

		<details class="notes">
			- Facilitate delegation pattern without restating members
			- Useful for protocols too
			- `ElementInternals`
			- Yes, this is not easily type-safe but that's inherent in all highly dynamic patterns in the language
		</details>
	</article>

	<article class="slide">
		<header>
			<h3><div class="block badge">Use cases</div> Dynamic class API surface</h3>
			<p class="subtitle">To DRY-fy repetitive code</p>
		</header>

		<p>Real example from <a href="https://github.com/babel/babel/blob/main/packages/babel-traverse/src/path/index.ts#L398-L413">Babel</a>:</p>

		<pre class="language-typescript"><code>
			for (const type of t.TYPES) {
				const typeKey = `is${type}`;
				const fn = t[typeKey];

				NodePath_Final.prototype[typeKey] = function (opts: any) {
					return fn.call(this.node, opts);
				};

				NodePath_Final.prototype[`assert${type}`] = function (opts: any) {
					if (!fn(this.node, opts)) {
						throw new TypeError(`Expected node path of type ${type}`);
					}
				};
			}
		</code></pre>
	</article>

	<article class="slide">
		<h3><div class="block badge">Use cases</div> Rudimentary mixins</h3>



		<div class="sbs">
			<ul>
				<li class="pro">Simple things are easy</li>
				<li class="pro">No inheritance chain pollution</li>
				<li class="pro"><code>super</code> works*</li>
			</ul>
			<ul>
				<li class="no">No privates</li>
				<li class="no">No dynamic <code>super</code></li>
				<li class="no">No introspection</li>
				<li class="no">No post-hoc application</li>
				<li class="con">Poor conflict resolution ergonomics</li>
			</ul>
		</div>
		<p class="delayed"><span class="badge">Important</span>
			Well suited to tightly coupled use cases,
			but not the end-all of class composition</p>
	</article>

	<article class="slide">
		<h3>
			<div class="block badge">Design space</div>
			Treat objects differently?
		</h3>

		<div class="sbs center">
			<div>
				<p class="md">Different behavior if  `obj.prototype` is falsy</p>

				<pre><code>
					import * as methods from "./methods.js";

					class Color {
						...methods;
					}
				</code></pre>
			</div>
			<strong>vs.</strong>
			<div>
				<p class="md">Always spread  `obj.prototype` ‚Üí `.prototype`</p>

				<pre><code>
					import * as methods from "./methods.js";

					class Color {
						...{prototype: methods};
					}
				</code></pre>
			</div>
		</div>
	</article>

	<article class="slide">
		<h3>
			<div class="block badge">Design space</div>
			Make fields always override?
		</h3>

		<div class="sbs start">
			<pre><code>
				class M {
					foo = 1;
				}
			</code></pre>
			<pre class="delayed"><code>
				class A {
					foo = 2;

					...M
				}

				(new A()).foo; // 1
			</code></pre>
			<pre class="delayed"><code>
				class A {
					...M;

					foo = 2;
				}

				(new A()).foo; // 2
			</code></pre>
		</div>
		<details class="notes">
			A potential footgun is that due to the order-sensitivity, for class fields to override mixin fields they have to be defined after the mixin.
			This breaks the usual practice of defining fields first.
			Are there use cases where this is actually desirable?
			If not, would it make sense to hoist host class fields to always be defined after spreading?
		</details>
	</article>
</section>

<section>
	<header class="slide">
		<h2>Class field introspection</h2>
	</header>

	<article class="slide md">
		### Core idea

		- Public fields are part of the class's API surface
		- (Public) static fields can be introspected, but not instance fields
		- _"Just create an instance"_ ‚Üí But side effects!
	</article>

	<article class="slide">
		<header>
			<h3>Public fields are class API</h3>
			<p class="subtitle">Accessor vs field is often an implementation detail</p>
		</header>

		<div class="sbs">
			<pre class="yes"><code>
				class A {
					#foo = 1;
					get foo() { return this.#foo; }
					set foo(value) { this.#foo = value; }
				}
			</code></pre>
			<pre class="no"><code>
				class A {
					foo = 1;
				}
			</code></pre>
		</div>
		<details class="notes">
			There is no reason why the first pattern would be introspectable from the outside and the second would not be.

			Sure, the underlying mechanics are different, fields are hung on the instance whereas methods and accessors are hung on the prototype,
			but to JS authors that is largely an implementation detail.
			When they need to run logic on property access or assignment, they use accessors.
			When they don't, they use fields because that's the language abstraction that is available and hanging value properties on the prototype is usually nonsensical.
			Other languages don't even expose such a distinction.
		</details>
	</article>

	<article class="slide">
		<header>
			<h3>Public fields are class API</h3>
			<p class="subtitle">Methods as fields</p>
		</header>

		<div class="sbs">
			<pre class="yes"><code>
				class A {
					foo () { return 1; }
				}
			</code></pre>
			<pre class="no"><code>
				class A {
					foo = function() { return 1; }
				}
			</code></pre>
		</div>
		<details class="notes">
			There are even cases where _methods_ are defined as class fields, for all sorts of reasons, e.g. to dynamically define them based on some condition.

			Effectively, public class fields have become _a new type of prototype_ holding part of the class shape.
			This just provides access to it.
		</details>
	</article>

	<article class="slide">
		<h3>Strawman</h3>

		<div class="sbs center">
			<pre><code>
				class A {
					foo = 1;
					static baz = 2;
				}

			</code></pre>
			<code class="arrow-right">A[Symbol.publicFields]</code>
			<pre><code>
				[
					{
						name: "foo",
						initializer(){
							return 1;
						}
						static: false
					},
					{
						name: "baz",
						initializer(){
							return 2;
						}
						static: true
					}
				]
			</code></pre>
			<ul>
				<li>Frozen array</li>
				<li>Properties non-writable, non-configurable</li>
				<li><code>initializer</code> lazily evaluated when first accessed</li>
			</ul>
		</div>
	</article>

	<article class="dumpster-fire slide">
		<h3>What about private fields?</h3>

		<div class="sbs">
			<section>
				<h4><span class="badge">POV</span> Expose all fields</span></h4>

				<ul>
					<li>Can be obtained from [[SourceText]] already</li>
					<li>Completeness</li>
				</ul>
			</section>
			<section>
				<h4><span class="badge">POV</span> Public fields only <span class="delayed">‚úÖ</span></h4>

				<ul>
					<li>Not part of the class API</li>
					<li>What's the use case?</li>
					<li>Can make progress faster</li>
					<li><code>Symbol.publicFields</code> allows <code>Symbol.fields</code> to ship later</li>
				</ul>
			</section>
		</div>
	</article>
</section>

<footer class="slide md">
	## Thank you!

	Links:
	- [github.com/webplatformco/project-class-composition](https://github.com/webplatformco/project-class-composition)
	- [github.com/leaverou/proposal-class-spread](https://github.com/leaverou/proposal-class-spread)
	- [github.com/leaverou/proposal-class-field-introspection](https://github.com/leaverou/proposal-class-field-introspection)
</footer>

</body>
