<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Control Over Image Animation</title>
	<link rel="shortcut icon" href="https://webplatform.design/assets/logo.svg">
	<script src="talk.js" type="module"></script>
	<link rel="stylesheet" href="talk.css">
</head>
<body data-markdown-elements=".md, details.notes, .md-children > :not(.no-md)" class="language-javascript">

<header class="slide" id="cover">
	<h1>
		Class composition
	</h1>
	<h2>Past, present, and future</h2>
	<footer>
		Lea Verou (OpenJS, Web Platform Collective)
	</footer>
</header>

<article class="slide md">
	## Overview

	1. Use cases
	2. Composition across languages
	3. Userland patterns
	4. Existing Stage 1+ proposals
	5. Design space & considerations
	6. Class spread syntax proposal
	7. Class public fields introspection proposal

</article>

<article class="slide md">
	<header>
		## Use cases
		<p class="subtitle">Class composition beyond inheritance</p>
	</header>

	- Modularity of class definitions
	- Polymorphism
	- Better data modeling for traits/behaviors (_has a_ vs _is a_)
	- True multiple inheritance
	- Transparent composition

	<details class="notes">
		The use cases for multiple inheritance are well-established in the literature.
		On a high level, they fall into the following categories:

		- Modularity for class definitions. Procedural APIs can be broken down into multiple modules, but the story is not quite as smooth for class surface.
		- Better data modeling: Support modeling _has a_ or _does a_ relationships distinctly from _is a_ relationships.
		- Transparent composition (the inheritance chain is observable to the outside)
	</details>
</article>

<article class="slide">
	<h3><div class="block badge">Use cases</div> Class modularity</h3>

	<div class="sbs center">
		<pre class="language-javascript"><code>
			import tokenize from "./methods/tokenize.js";
			import highlight from "./methods/highlight.js";
			// ...

			class Prism {
				// constructor elided
				tokenize (text, grammar) {
					return tokenize.call(this, text, grammar);
				}
				highlight (text, language, options = {}) {
					return highlight.call(this, text, language, options);
				}
				// ...
			}
		</code></pre>
	</div>
	<details class="notes">
		- Large classes benefit from modularization for the same reason as procedural APIs.
		Every method requires boilerplate to forward it to the method in the module.
		Function signatures have to be duplicated for typing.
		- This is a similified but real example from [Prism's v2 codebase](https://github.com/PrismJS/prism/blob/v2/src/core/classes/prism.js).
		- [This Babel class](https://github.com/babel/babel/blob/main/packages/babel-traverse/src/path/index.ts) is even more egregious
	</details>
</article>

<article class="slide" data-type="Use cases">
	<h3><div class="block badge">Use cases</div> Procedural & OOP Polymorphism</h3>

	<div class="sbs start">
		<div>
			<pre><div class="filename">mix.js</div><code>
				export default function mix (color, color2) {
					// elided
				}
			</code></pre>
			<pre><div class="filename">toString.js</div><code>
				export default function toString (color) {
					// elided
				}
			</code></pre>
		</div>
		<pre><div class="filename">color.js</div><code>
			import mix from "./mix.js";
			import toString from "./toString.js";

			class Color {
				mix (color) {
					return mix(this, color);
				}
				toString () {
					return toString(this);
				}
			}
		</code></pre>
	</div>
</article>

<article class="slide md">
	<h2>Example: `EventTarget`</h2>

	<ul>
		<li>Capability, not identity</li>
		<li class="delayed md">Direct subclasses: `Node`, `Window`, `IDBRequest`, `AudioNode`, `AudioContext`</li>
		<li class="delayed md">`ArrayStream extends Array` ‚Üí cannot make it an event target</li>
	</ul>
</article>

<section>
	<header class="slide">
		<h2>Composition across languages</h2>
	</header>

	<article class="slide columns-3">
		<h3>Full-on Multiple inheritance</h3>
		<section>
			<h4>Python</h4>
			<pre class="language-python"><code>
				class M1:
					def foo(self): print("M1")

				# M2, M3 elided

				class A(M1, M2, M3):
					pass
			</code></pre>
		</section>
		<section>
			<h4>C++</h4>
			<pre class="language-cpp"><code>
				class M1 {
				public:
					void foo() { std::cout << "M1"; }
				};

				// M2, M3 elided

				class A : public M1,
				          public M2,
				          public M3 {
					// ...
				};
			</code></pre>
		</section>
		<section>
			<h4>Eiffel</h4>
			<pre class="language-eiffel"><code>
				class M1
					feature foo do print("M1") end
				end

				-- M2, M3 elided

				class A inherit M1 M2 M3
					-- ...
				end
			</code></pre>
		</section>
	</article>

	<article class="slide columns-3">
		<h3>Interfaces</h3>
		<section>
			<h4>Java 8+</h4>
			<pre class="language-java"><code>
				interface M1 {
					default void foo() {
						System.out.println("M1");
					}
				}

				// M2, M3 elided

				class A extends B implements M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>C#</h4>
			<pre class="language-csharp"><code>
				interface M1 {
					void foo() { Console.WriteLine("M1"); }
				}

				// M2, M3 elided


				class A extends B implements M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Kotlin</h4>
			<pre class="language-kotlin"><code>
				interface M1 {
					fun foo() { println("M1"); }
				}

				// M2, M3 elided

				class A : B(), M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
	</article>

	<article class="slide columns-3">
		<h3>Mixins</h3>

		<section>
			<h4>Ruby</h4>
			<pre class="language-ruby"><code>
				module M1
					def foo
						puts "M1"
					end
				end

				# M2, M3 elided

				class A < B
					include M1
					include M2
					include M3
				end
			</code></pre>
		</section>
		<section>
			<h4>Dart</h4>
			<pre class="language-dart"><code>
				mixin M1 {
					void foo() { print("M1"); }
				}

				// M2, M3 elided

				class A extends B with M1, M2, M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Groovy</h4>
			<pre class="language-groovy"><code>
				class M1 {
					def foo() { println "M1" }
				}

				// M2, M3 elided

				class A extends B {}

				A.metaClass.mixin M1, M2, M3
			</code></pre>
		</section>
	</article>

	<article class="slide columns-3">
		<h3>Traits</h3>
		<section>
			<h4>PHP</h4>
			<pre class="language-php"><code>
				trait M1 {
					public function foo() {
						echo "M1";
					}
				}

				// M2, M3 elided

				class A extends B {
					use M1, M2, M3;
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Scala</h4>
			<pre class="language-swift"><code>
				trait M1 {
					def foo: String = "M1"
				}

				// M2, M3 elided

				class A extends B with M1 with M2 with M3 {
					// ...
				}
			</code></pre>
		</section>
		<section>
			<h4>Rust</h4>
			<pre class="language-rust"><code>
				pub trait M1 {
					fn foo(&self) { println!("M1"); }
				}

				// M2, M3 elided

				// no way to do extends B,
				// only composition or delegation
				struct A;

				impl M1 for A {}
				impl M2 for A {}
				impl M3 for A {}
			</code></pre>
		</section>
	</article>

	<article class="slide">
		<h3>Haskell Typeclasses</h3>
		<pre class="language-haskell"><code>
			class M1 a where
				m1 :: a -> a
			class M2 a where
				m2 :: a -> a
			class A a where
				a :: a -> a

			class A a where
				a :: a -> a deriving (M1, M2)
		</code></pre>
	</article>
</section>

<section>
	<header class="slide">
		<h2>Userland patterns</h2>
	</header>

	<article class="slide columns-2">
		<h3>Example going forwards</h3>

		<img src="images/shape.svg" alt="Shape">

		<ul class="md-children">
			<li>Host class: `EquilateralTriangle`
			<li>Superclass: `Triangle`
			<li>Mixin: `RegularPolygon` with a `getArea()` method that implements the formula:
			<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
				<mrow>
					<mi>A</mi><mo>=</mo>
					<mfrac>
						<mrow>
							<mi>n</mi>
							<msup>
								<mi>s</mi><mn>2</mn>
							</msup>
						</mrow>
						<mrow>
							<mn>4</mn><mo>&InvisibleTimes;</mo><mi>tan</mi>
							<mfenced>
								<mfrac><mi>&pi;</mi><mi>n</mi></mfrac>
							</mfenced>
						</mrow>
					</mfrac>
				</mrow>
			</math>
		</div>
	</article>

	<article class="slide">
		<h3>Subclass factories</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				const RegularPolygon = S =>
				class RegularPolygon extends S {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							(4 * Math.tan(Math.PI / sides));
					}
				}
			</code></pre>
			<pre><code>
				class EquilateralTriangle extends RegularPolygon(Triangle) {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
		</div>
		<div class="sbs">
			<ul>
				<li class="pro"><code>super</code> works</li>
				<li class="pro">Private members</li>
			</ul>
			<ul>
				<li class="con">Affects inheritance chain</li>
				<li class="con">No <code>instanceof</code> checks</li>
				<li class="con">Mixin class needs to support it</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<h3>Delegation pattern</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				class RegularPolygon {
					constructor (sideLength, sides) {
						this.sideLength = sideLength;
						this.sides = sides;
					}

					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
						       (4 * Math.tan(Math.PI / sides));
					}
				}
			</code></pre>
			<pre><code>
				class EquilateralTriangle extends Triangle {
					#regularPolygon = new RegularPolygon(this.sideLength, 3);
					constructor() {
						this.sideLength = sideLength;
					}

					// Glue code
					getArea () {
						return this.#regularPolygon.getArea();
					}
				}
			</code></pre>
		</div>
		<div class="sbs">
			<ul>
				<li class="pro">Separate state</li>
				<li class="pro">Separate inheritance chain</li>
				<li class="pro">Private members</li>
				<li class="pro">Mixin class does not need to be aware</li>
			</ul>
			<ul>
				<li class="con">Glue code</li>
			</ul>
		</div>

	</article>

	<article class="slide" style="flex-flow: row; gap: 3rem">
		<h2 style="text-align: right;">
			<span class="badge">Example</span>
			Custom form controls
		</h2>
		<pre><code>
			class MyElement extends HTMLElement {
				// This tells ElementInternals that this element is form associated
				static formAssociated = true;

				constructor() {
					super();
					this._internals = this.attachInternals();
					// then use this._internals.setFormValue(value)
				}

				// API glue code
				get labels () { return this._internals.labels; }
				get form () { return this._internals.form; }
				get validity () { return this._internals.validity; }
				get validationMessage () { return this._internals.validationMessage; }
				willValidate (...args) { return this._internals.willValidate(...args); }
				reportValidity(...args) { return this._internals.reportValidity(...args); }
				checkValidity(...args) { return this._internals.checkValidity(...args); }
				// ...
			}
		</code></pre>
	</article>

	<article class="slide">
		<h3>Prototype mutations</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				const RegularPolygon = {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					}
				};
			</code></pre>
			<pre><code>
				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}

				Object.assign(EquilateralTriangle.prototype, RegularPolygon);

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
		</div>
		<div class="sbs">
			<ul>
				<li class="pro">Flexible</li>
				<li class="pro">Transparent</li>
			</ul>
			<ul>
				<li class="con">No private members</li>
				<li class="con">No <code>instanceof</code> checks</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<h3>Instance mutations</h3>

		<div class="sbs">
			<pre class="language-javascript"><code>
				const RegularPolygon = {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					}
				};
			</code></pre>
			<pre><code>
				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
						Object.assign(this, RegularPolygon);
					}
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>

		</div>
		<div class="sbs">
			<ul>
				<li class="pro">Flexible</li>
				<li class="pro">Transparent</li>
			</ul>
			<ul>
				<li class="con">Inefficient</li>
				<li class="con">No introspection</li>
			</ul>
		</div>
	</article>
</section>

<section>
	<header class="slide">
		<h2>TC39 Stage 1+ proposals</h2>
	</header>

	<article class="slide">
		<header>
			<h3>First-class protocols</h3>
			<a href="https://github.com/tc39/proposal-first-class-protocols" class="subtitle">tc39/proposal-first-class-protocols</a>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				protocol RegularPolygon {
					sideLength;
					sides;

					getArea () {
						let sides = this[RegularPolygon.sides];
						let sideLength = this[RegularPolygon.sideLength];
						return sides * sideLength ** 2 /
						       (4 * Math.tan(Math.PI / sides));
					}
				}

				class EquilateralTriangle extends Triangle {
					[RegularPolygon.sides] = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this[RegularPolygon.sideLength] = sideLength;
					}

					getArea () {
						return this[RegularPolygon.getArea]();
					}
				}
				Protocol.implement(EquilateralTriangle, RegularPolygon);

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
			<ul>
				<li class="pro">Avoids conflicts via symbols</li>
				<li class="pro">Can be applied post-hoc</li>
				<li class="con">Duplicated author intent ‚Üí error conditions</li>
				<li class="con">Manual glue code</li>
				<li class="con">Often criticized for ergonomics</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<header>
			<h3>Maximally minimal mixins</h3>
			<a class="subtitle" href="https://github.com/tc39/proposal-mixins">tc39/proposal-mixins</a>
		</header>


		<div class="sbs">
			<pre class="language-javascript"><code>
				mixin RegularPolygon {
					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
						       (4 * Math.tan(Math.PI / sides));
					}
				}

				class EquilateralTriangle extends Triangle with RegularPolygon {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
			<ul>
				<li class="pro">Can add API surface AND provides control over conflicts</li>
				<li class="pro"><code>super</code> works</li>
				<li class="pro">Private members</li>
				<li class="pro">Easy to implement</li>
				<li class="con">Inheritance chain pollution</li>
				<li class="con">Class definition time only</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<header>
			<h3>Decorators</h3>
			<a class="subtitle" href="https://github.com/tc39/proposal-decorators">tc39/proposal-decorators</a>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				@RegularPolygon
				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}
				}
			</code></pre>
			<span class="emoji delayed">üòç</span>
		</div>
	</article>
	<article class="slide">
		<header>
			<h3>Peeking behind the curtain</h3>
			<p class="subtitle delayed" data-index="2">Same patterns, just better encapsulated</p>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				function RegularPolygon (Class, context) {
					return class extends Class {
						getArea () {
							if (super.getArea) {
								return super.getArea();
							}

							const {sideLength, sides} = this;
							return sides * sideLength ** 2 /
								   (4 * Math.tan(Math.PI / sides));
						}
					}
				}
			</code></pre>
			<pre class="language-javascript delayed" data-index="1"><code>
				function RegularPolygon (Class, context) {
					Class.prototype.getArea = function() {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					};
				}
			</code></pre>
		</div>

	</article>


</section>

<section>
	<header class="slide">
		<h2>Design space & considerations</h2>
	</header>

	<article class="slide md">
		## Requirements

		- API surface, not just logic
		- No inheritance chain pollution
		- Memory efficient (prototypes > instances)
		- Encapsulation
	</article>

	<article class="slide md">
		## Nice to haves

		- Single declaration of intent
		- Introspection (`A` uses `M1`?)
	</article>

	<article class="slide">
		<h3>Priority of constituencies</h3>

		<ul>
			<li><a href="https://www.w3.org/TR/design-principles/#priority-of-constituencies">Original PoC</a>: Authors > Implementers > Spec editors > Purity</li>
			<li class="delayed"><a href="https://lea.verou.me/blog/2025/user-effort/#consumers-over-producers">Generalization</a>: Consumers > producers</li>
			<li class="delayed">Host class author > Mixin author > Platform implementers</li>
		</ul>
	</article>

	<article class="slide" style="flex-flow: row; gap: 3rem">
		<h2 style="text-align: right"><span class="badge">Proposed principle</span> Syntax in class body iff order matters</h2>

		<div style="min-width: 40rem">
			<p>Let‚Äôs not be like Ruby here:</p>
			<pre class="language-ruby"><code>
				class A
					def m1
						puts "M1"
					end

					# Hoisted
					include M1

					def m1
						puts "M1"
					end
				end
			</code></pre>
		</div>
	</article>

	<article class="slide columns-2 dont-resize">
		<h2>Diamond problem?</h2>

		<img src="images/diamond.svg" alt="Shape">

		<div class="md">
			```js
			let t = new EquilateralTriangle(4);
			t.getArea(); // which one?
			```

			- Limited in JS, as **no stateful subinstances** like C++
			- Most discourse about the _deadly diamond of death_ is actually around **conflict resolution / MRO**
			- Diamond issues can still come up around **method call duplication**
		</div>
		<details class="notes">
			- Conflict resolution is orthogonal to diamond inheritance.
			- Diamond issues when you have something like `super`.
		</details>
	</article>

	<!-- <article class="slide">
		<header>
			<h2>Diamond problem in JS</h2>
			<p class="subtitle">With na√Øve multiple inheritance</p>
		</header>

		<div class="sbs start">
			<pre><code>
				class A {
					constructor (n) {
						this.n = n;
						sideEffect();
					}
				}


			</code></pre>
			<pre><code>
				class B extends A {
					constructor () {
						super(1);
					}
				}
				class C extends A {
					constructor () {
						super(2);
					}
				}
			</code></pre>
			<pre><code>
				class D extends B, C {
					constructor () {
						super();
					}
				}

				(new D()).n; // ???
				// sideEffect() 1x or 2x?
			</code></pre>
		</div>

		<details class="notes">
			- Conflict resolution is orthogonal to diamond inheritance.
			- Diamond issues when you have something like `super`.
		</details>
	</article> -->

	<article class="slide">
		<h2>Single inheritance resolution</h2>

		<div class="sbs">
			<section>
				<h3>Default: Subclass overrides superclass</h3>
				<pre class="language-javascript"><code>
					class A {
						foo () { console.log("A") }
					}
					class B extends A {
						foo () { console.log("B") }
					}

					new B(); // "B"
				</code></pre>
			</section>
			<section>
				<h3 class="md">Subclass can use `super` to override</h3>
				<pre class="language-javascript"><code>
					class A {
						foo () { console.log("A") }
					}
					class B extends A {
						foo () {
							super.foo();
							console.log("B")
						}
					}
				</code></pre>
			</section>
		</div>
	</article>

	<article class="slide md">
		<h2>Multiple inheritance resolution</h2>

		<div class="md">
			Multiple strategies, not mutually exclusive:
			- Distinct single inheritance chain
			- Linearization (usually [C3](https://justanotherdev7.medium.com/understanding-pythons-c3-linearization-algorithm-c92909dacf1d))
			- Last one wins typically a factor to some degree
			- Error on conflicts, forcing disambiguation
			- Renaming at host class
			- Composition
		</div>
	</article>

	<article class="slide md">
		<h2>Java 8+</h2>

		- Single inheritance + interfaces
		- Interfaces = contracts + default implementations
		- **Precedence:** Inheritance > interfaces
		- **Error:** if conflict between interfaces w/o disambiguation
		- **Disambiguation:**
			- `InterfaceName.super`
			- `super` is inheritance only
	</article>

	<article class="slide">
		<h2>Eiffel</h2>
		<div class="sbs">
			<div class="md">
				- Renaming at the point of inclusion
				- No generic `super`
				- `Precursor` must specify which superclass to use (e.g. `Precursor {M1}`)
			</div>
			<pre class="language-eiffel"><code>
				class A
					inherit M1
						rename
							f as f_from_a
						end
					M2
				end
			</code></pre>
		</div>
	</article>

	<article class="dumpster-fire slide md">
		## Hairiest issues ü™Æ

		- Is post-hoc composition desirable?
		- Should the mixin class need to opt-in?
		- Private members
		- Naming conflicts: explicit vs. implicit
		- Function composition: explicit vs. implicit
	</article>
</section>

<section>
	<header class="slide">
		<h1>How can we make progress?</h1>
	</header>

	<article class="slide md">
		## Different use cases, different primitives?

		- Most controversy is around **loosely coupled use cases**
		- Tightly coupled use cases don't need sophisticated conflict management
		- Tightly coupled use cases don't need post-hoc application
	</article>

	<article class="slide">
		<h2>Proposed path forwards</h2>

		<ul>
			<li>High-level primitives for tightly coupled use cases <span class="delayed">‚Üí Class spread syntax</span></li>
			<li>Low-level primitives to make userland helpers easier for loosely coupled use cases <span class="delayed">‚Üí Fields introspection</span></li>
			<li>Low-level primitives can also be used to <strong>explain</strong> the high-level ones</li>
		</ul>
	</article>
</section>

<section>
	<header class="slide">
		<h2>Class spread syntax</h2>
	</header>

	<article class="slide columns-2">
		<h3>Core idea</h3>

		<div>
			<pre class="yes"><code>const arr = [...arr1, ...arr2];</code></pre>

			<pre class="yes"><code>console.log(...iterable);</code></pre>

			<pre class="yes"><code>const obj = { ...obj1, ...obj2 };</code></pre>

			<pre class="no"><code>
				class A extends B { ...Mixin }
			</code></pre>
		</div>

		<ul>
			<li>Like object spread, but copies descriptors</li>
			<li>Low-level semantics, no sophisticated MRO</li>
		</ul>
	</article>

	<article class="slide">
		<header>
			<h3>Core idea</h3>
			<p class="subtitle">Spreading constructor ‚Üí class definition</p>
		</header>

		<div class="sbs">
			<pre class="language-javascript"><code>
				class RegularPolygon {
					constructor (sideLength, sides) {
						this.sideLength = sideLength;
						this.sides = sides;
					}

					getArea () {
						const {sideLength, sides} = this;
						return sides * sideLength ** 2 /
							   (4 * Math.tan(Math.PI / sides));
					}
				}
			</code></pre>
			<pre class="language-javascript"><code>
				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}

					...RegularPolygon;
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
		</div>
	</article>

	<article class="slide">
		<header>
			<h3>Core idea</h3>
			<p class="subtitle">Spreading object ‚Üí class definition</p>
		</header>

		<div class="sbs">
			<pre><div class="filename">regular-polygon.js</div><code>
				export function getArea (params = this) {
					const {sideLength, sides} = params;
					return sides * sideLength ** 2 /
							(4 * Math.tan(Math.PI / sides));
				}
			</code></pre>

			<pre class="language-javascript"><code>
				import * as RegularPolygon from "./regular-polygon.js";

				class EquilateralTriangle extends Triangle {
					sides = 3;

					constructor (sideLength) {
						super(sideLength, sideLength, sideLength);
						this.sideLength = sideLength;
					}

					...{prototype: RegularPolygon};
				}

				(new EquilateralTriangle(4)).getArea(); // 6.93
			</code></pre>
		</div>
	</article>

	<article class="slide md">
		### Use cases

		- Class modularity
		- Code sharing across procedural and OOP APIs
		- Dynamically generating class API surface
		- Rudimentary mixins
	</article>

	<article class="slide">
		<h3><div class="block badge">Use cases</div> Class modularity</h3>

		<div class="sbs center">
			<pre class="language-javascript"><code>
				import tokenize from "./methods/tokenize.js";
				import highlight from "./methods/highlight.js";
				// ...

				class Prism {
					// constructor elided
					tokenize (text, grammar) {
						return tokenize.call(this, text, grammar);
					}
					highlight (text, language, options = {}) {
						return highlight.call(this, text, language, options);
					}
					// ...
				}
			</code></pre>
			<div class="arrow-right"></div>
			<pre class="language-javascript"><code>
				import * as methods from "./methods.js";

				class Prism {
					...methods;
				}
			</code></pre>
		</div>
		<details class="notes">
			- Large classes benefit from modularization for the same reason as procedural APIs.
			Every method requires boilerplate to forward it to the method in the module.
			Function signatures have to be duplicated for typing.
			- This is a similified but real example from [Prism's v2 codebase](https://github.com/PrismJS/prism/blob/v2/src/core/classes/prism.js).
			- [This Babel class](https://github.com/babel/babel/blob/main/packages/babel-traverse/src/path/index.ts) is even more egregious
		</details>
	</article>

	<article class="slide" data-type="Use cases">
		<h3><div class="block badge">Use cases</div> Procedural & OOP Polymorphism</h3>

		<div class="sbs start">
			<div>
				<pre><div class="filename">mix.js</div><code>
					export default function mix (color, color2) {
						// elided
					}
				</code></pre>
				<pre><div class="filename">toString.js</div><code>
					export default function toString (color) {
						// elided
					}
				</code></pre>
				<pre><div class="filename">color.js</div><code>
					import mix from "./mix.js";
					import toString from "./toString.js";

					class Color {
						mix (color) {
							return mix(this, color);
						}
						toString () {
							return toString(this);
						}
					}
				</code></pre>
			</div>
			<div class="arrow-right"></div>
			<div>
				<pre><div class="filename">mix.js</div><code>
					export default function mix (color, color2) {
						if (this) [color, color2] = [this, color];
						// elided
					}
				</code></pre>
				<pre><div class="filename">toString.js</div><code>
					export default function toString (color) {
						let color = this ?? color;
						// elided
					}
				</code></pre>
				<pre><div class="filename">color.js</div><code>
					import mix from "./mix.js";
					import toString from "./toString.js";

					class Color {
						...{prototype: {mix, toString}};
					}
				</code>
			</div>

		</div>
	</article>

	<article class="slide">
		<header>
			<h3><div class="block badge">Use cases</div> Dynamic class API surface</h3>
			<p class="subtitle">For maintainability and future-proofing</p>
		</header>

		<div class="sbs start">
			<pre><code>
				lass EquilateralTriangle extends Triangle {
					#regularPolygon = new RegularPolygon(this.sideLength, 3);

					constructor() {
						this.sideLength = sideLength;
					}

					getArea () {
						return this.#regularPolygon.getArea();
					}

					// ...
				}
			</code></pre>
			<div class="arrow-right"></div>
			<pre><code>
				class EquilateralTriangle extends Triangle {
					#regularPolygon = new RegularPolygon(this.sideLength, 3);

					constructor() {
						this.sideLength = sideLength;
					}

					[...getMembers(RegularPolygon.prototype).map(key =>
						[key, function (...args) {
							return this.#regularPolygon[key](...args);
						}]
					)]
				}
			</code></pre>
		</div>

		<p><span class="badge">Examples</span> Delegation pattern, <code>ElementInternals</code>, First Class Protocols glue code, etc.</p>

		<details class="notes">
			- Facilitate delegation pattern without restating members
			- Useful for protocols too
			- `ElementInternals`
			- Yes, this is not easily type-safe but that's inherent in all highly dynamic patterns in the language
		</details>
	</article>

	<article class="slide">
		<header>
			<h3><div class="block badge">Use cases</div> Dynamic class API surface</h3>
			<p class="subtitle">To DRY-fy repetitive code</p>
		</header>

		<p>Real example from <a href="https://github.com/babel/babel/blob/main/packages/babel-traverse/src/path/index.ts#L398-L413">Babel</a>:</p>

		<pre class="language-typescript"><code>
			for (const type of t.TYPES) {
				const typeKey = `is${type}`;
				const fn = t[typeKey];

				NodePath_Final.prototype[typeKey] = function (opts: any) {
					return fn.call(this.node, opts);
				};

				NodePath_Final.prototype[`assert${type}`] = function (opts: any) {
					if (!fn(this.node, opts)) {
						throw new TypeError(`Expected node path of type ${type}`);
					}
				};
			}
		</code></pre>
	</article>

	<article class="slide">
		<h3><div class="block badge">Use cases</div> Rudimentary mixins</h3>

		<div class="sbs">
			<ul>
				<li class="pro">Simple things are easy</li>
				<li class="pro">No inheritance chain pollution</li>
				<li class="pro"><code>super</code> works*</li>
			</ul>
			<ul>
				<li class="no">No privates</li>
				<li class="no">No dynamic <code>super</code></li>
				<li class="no">No introspection</li>
				<li class="no">No post-hoc application</li>
				<li class="con">Poor conflict resolution ergonomics</li>
			</ul>
		</div>
		<p class="delayed"><span class="badge">Important</span>
			Well suited to tightly coupled use cases,
			but not the end-all of class composition</p>
	</article>

	<article class="slide">
		<h3>
			<div class="block badge">Design space</div>
			Treat objects differently?
		</h3>

		<div class="sbs center">
			<div>
				<p class="md">Different behavior if  `obj.prototype` is falsy</p>

				<pre><code>
					import * as methods from "./methods.js";

					class Color {
						...methods;
					}
				</code></pre>
			</div>
			<strong>vs.</strong>
			<div>
				<p class="md">Always spread  `obj.prototype` ‚Üí `.prototype`</p>

				<pre><code>
					import * as methods from "./methods.js";

					class Color {
						...{prototype: methods};
					}
				</code></pre>
			</div>
		</div>
	</article>

	<article class="slide">
		<h3>
			<div class="block badge">Design space</div>
			Make fields always override?
		</h3>

		<div class="sbs start">
			<pre><code>
				class M {
					foo = 1;
				}
			</code></pre>
			<pre class="delayed"><code>
				class A {
					foo = 2;

					...M
				}

				(new A()).foo; // 1
			</code></pre>
			<pre class="delayed"><code>
				class A {
					...M;

					foo = 2;
				}

				(new A()).foo; // 2
			</code></pre>
		</div>
		<details class="notes">
			A potential footgun is that due to the order-sensitivity, for class fields to override mixin fields they have to be defined after the mixin.
			This breaks the usual practice of defining fields first.
			Are there use cases where this is actually desirable?
			If not, would it make sense to hoist host class fields to always be defined after spreading?
		</details>
	</article>

	<article class="slide">
		<h3>Can I haz Stage 1?</h3>
	</article>
</section>

<section>
	<header class="slide">
		<h2>Class field introspection</h2>
	</header>

	<article class="slide md">
		### Core idea

		- Public fields are part of the class's API surface
		- (Public) static fields can be introspected, but not instance fields
		- _"Just create an instance"_ ‚Üí But side effects!
	</article>

	<article class="slide">
		<header>
			<h3>Public fields are class API</h3>
			<p class="subtitle">Accessor vs field is often an implementation detail</p>
		</header>

		<div class="sbs">
			<pre class="yes"><code>
				class A {
					#foo = 1;
					get foo() { return this.#foo; }
					set foo(value) { this.#foo = value; }
				}
			</code></pre>
			<pre class="no"><code>
				class A {
					foo = 1;
				}
			</code></pre>
		</div>
		<details class="notes">
			There is no reason why the first pattern would be introspectable from the outside and the second would not be.

			Sure, the underlying mechanics are different, fields are hung on the instance whereas methods and accessors are hung on the prototype,
			but to JS authors that is largely an implementation detail.
			When they need to run logic on property access or assignment, they use accessors.
			When they don't, they use fields because that's the language abstraction that is available and hanging value properties on the prototype is usually nonsensical.
			Other languages don't even expose such a distinction.
		</details>
	</article>

	<article class="slide">
		<header>
			<h3>Public fields are class API</h3>
			<p class="subtitle">Methods as fields</p>
		</header>

		<div class="sbs">
			<pre class="yes"><code>
				class A {
					foo () { return 1; }
				}
			</code></pre>
			<pre class="no"><code>
				class A {
					foo = function() { return 1; }
				}
			</code></pre>
		</div>
		<details class="notes">
			There are even cases where _methods_ are defined as class fields, for all sorts of reasons, e.g. to dynamically define them based on some condition.

			Effectively, public class fields have become _a new type of prototype_ holding part of the class shape.
			This just provides access to it.
		</details>
	</article>

	<article class="slide">
		<h3>Strawman</h3>

		<div class="sbs center">
			<pre><code>
				class A {
					foo = 1;
					static baz = 2;
				}

			</code></pre>
			<code class="arrow-right">A[Symbol.publicFields]</code>
			<pre><code>
				[
					{
						name: "foo",
						initializer(){
							return 1;
						}
						static: false
					},
					{
						name: "baz",
						initializer(){
							return 2;
						}
						static: true
					}
				]
			</code></pre>
			<ul>
				<li>Frozen array</li>
				<li>Properties non-writable, non-configurable</li>
				<li><code>initializer</code> lazily evaluated when first accessed</li>
			</ul>
		</div>
	</article>

	<article class="dumpster-fire slide">
		<h3>What about private fields?</h3>

		<div class="sbs">
			<section>
				<h4><span class="badge">POV</span> Expose all fields</span></h4>

				<ul>
					<li>Can be obtained from [[SourceText]] already</li>
					<li>Completeness</li>
				</ul>
			</section>
			<section>
				<h4><span class="badge">POV</span> Public fields only <span class="delayed">‚úÖ</span></h4>

				<ul>
					<li>Not part of the class API</li>
					<li>What's the use case?</li>
					<li>Can make progress faster</li>
					<li><code>Symbol.publicFields</code> allows <code>Symbol.fields</code> to ship later</li>
				</ul>
			</section>
		</div>
	</article>

	<article class="slide">
		<h3>Can I haz Stage 1?</h3>
	</article>
</section>

<footer class="slide md">
	## Thank you!

	Links:
	- [github.com/webplatformco/project-class-composition](https://github.com/webplatformco/project-class-composition)
	- [github.com/leaverou/proposal-class-spread](https://github.com/leaverou/proposal-class-spread)
	- [github.com/leaverou/proposal-class-field-introspection](https://github.com/leaverou/proposal-class-field-introspection)
</footer>

</body>
